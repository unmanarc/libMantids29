#pragma once

#include <string>
#include <stdint.h>

#include <Mantids30/Helpers/encoders.h>
#include <Mantids30/Helpers/crypto.h>
#include <Mantids30/Helpers/random.h>
#include <Mantids30/Helpers/json.h>

namespace Mantids30 { namespace Auth {

/**
 * @brief The Function enum defines the supported password hashing and authentication functions.
 *
 * The Function enum defines the supported password hashing and authentication functions. Each function is assigned a numerical value that can be used to specify the function when calling a related function.
 *
 * The available functions are:
 * - FN_NOTFOUND: Not found or invalid function.
 * - FN_PLAIN: Plain-text password storage (not recommended).
 * - FN_SHA256: Password hashed with SHA-256 algorithm.
 * - FN_SHA512: Password hashed with SHA-512 algorithm.
 * - FN_SSHA256: Password hashed with salted SHA-256 algorithm.
 * - FN_SSHA512: Password hashed with salted SHA-512 algorithm.
 * - FN_GAUTHTIME: Time-based one-time password (TOTP) generated by Google Authenticator.
 */
enum Function
{
    FN_NOTFOUND=500,
    FN_PLAIN=0,
    FN_SHA256=1,
    FN_SHA512=2,
    FN_SSHA256=3,
    FN_SSHA512=4,
    FN_GAUTHTIME=5
};

enum Mode
{
    MODE_PLAIN,   // NOT RECOMMENDED.
    MODE_CHALLENGE
};

static Mode getAuthModeFromString( const std::string & mode )
{
    if (mode == "CHALLENGE")
        return MODE_CHALLENGE;
    else
        return MODE_PLAIN;
}

static std::string getStringFromAuthMode( const Mode & mode )
{
    switch (mode)
    {
    case MODE_PLAIN:
        return "PLAIN";
    case MODE_CHALLENGE:
        return "CHALLENGE";
    };
    return "PLAIN";
}

struct AuthenticationPolicy
{
    uint32_t maxTries = 4;
    uint32_t abandonedAccountExpirationSeconds = 180 * 24 * 3600; // 6 Months..

    // TODO: separar esto...
    uint32_t blockTokenTimeout = 7 * 24 * 3600;                   // 7 days..
};

struct AuthenticationSlotDetails
{
    void fromJSON(const json & j)
    {
        passwordFunction = (Function)JSON_ASINT(j,"passwordFunction",(int)FN_NOTFOUND);
        description = JSON_ASSTRING(j,"description","");
        defaultExpirationSeconds = JSON_ASUINT(j,"defaultExpirationSeconds",0);
        strenghtJSONValidator = JSON_ASSTRING(j,"strenghtJSONValidator","");
        totp2FAStepsToleranceWindow = JSON_ASUINT(j,"totp2FAStepsToleranceWindow",0);
    }

    json toJSON()
    {
        json jRet;
        jRet["description"] = description;
        jRet["defaultExpirationSeconds"] = defaultExpirationSeconds;
        jRet["strenghtJSONValidator"] = strenghtJSONValidator;
        jRet["passwordFunction"] = (int)passwordFunction;
        jRet["totp2FAStepsToleranceWindow"] = totp2FAStepsToleranceWindow;
        return jRet;
    }

    bool isCompatible(const AuthenticationSlotDetails & x)
    {
        return x.passwordFunction==passwordFunction;
    }

    bool isTextPasswordFunction()
    {
        return passwordFunction!=FN_NOTFOUND && passwordFunction!=FN_GAUTHTIME;
    }


    AuthenticationSlotDetails(const std::string& desc, Function pwdFunction, const std::string& strenghtValidator,
                              uint32_t defaultExpSecs, uint32_t totpToleranceWindow)
        : description(desc), passwordFunction(pwdFunction), strenghtJSONValidator(strenghtValidator),
        defaultExpirationSeconds(defaultExpSecs), totp2FAStepsToleranceWindow(totpToleranceWindow) {}

    AuthenticationSlotDetails()
    {
    }

    std::string description;

    // TODO: implementar... JSON Validator, totp2FAStepsToleranceWindow
    Function passwordFunction = FN_NOTFOUND;
    std::string strenghtJSONValidator;
    uint32_t defaultExpirationSeconds = 0;
    uint32_t totp2FAStepsToleranceWindow = 0;
};


struct Credential
{

    void fromJSON(const json & j)
    {
        slotDetails.fromJSON(j["slotDetails"]);
        forceExpiration = JSON_ASBOOL(j,"forceExpiration",true);
        badAttempts = JSON_ASUINT(j,"badAttempts",0);
        expirationTimestamp = (time_t)JSON_ASUINT64(j,"expirationTimestamp",0);
        hash = JSON_ASSTRING(j,"hash","");
        Helpers::Encoders::fromHex(JSON_ASSTRING(j,"hash","FFFFFFFF"), ssalt,4);
    }

    json toJSON(const AuthenticationPolicy & authPolicy)
    {
        json jRet;
        jRet["slotDetails"] = slotDetails.toJSON();
        jRet["forceExpiration"] = forceExpiration;
        jRet["badAttempts"] = badAttempts;
        jRet["expirationTimestamp"] = expirationTimestamp;
        jRet["hash"] = hash;
        jRet["ssalt"] = Helpers::Encoders::toHex(ssalt,4);

        jRet["isExpired"] = isAccountExpired();
        jRet["isLocked"] = isLocked(authPolicy);

        return jRet;
    }

    Credential getPublicData()
    {
        Credential credPubData = *this;
        credPubData.hash = "";
        return credPubData;
    }

    bool isLocked(const AuthenticationPolicy & authPolicy) const
    {
        return (badAttempts+1) >= authPolicy.maxTries;
    }

    bool isAccountExpired() const
    {
        return (time(nullptr)>expirationTimestamp && expirationTimestamp!=0) || forceExpiration;
    }

    bool forceExpiration = true;
    uint32_t badAttempts = 0;
    // 0 means that the password does not expire... 1 means that it's expired unless and when you change the password, the expiration will be set to current time + slot default time...
    time_t expirationTimestamp = 1;
    std::string hash;
    unsigned char ssalt[4] = {0xFF,0xFF,0xFF,0xFF};
    AuthenticationSlotDetails slotDetails;

};

enum Reason
{
    REASON_AUTHENTICATED=0,             // AUTHENTICATED!
    REASON_INTERNAL_ERROR=500,          // INTERNAL ERROR (OTHER)
    REASON_NOT_IMPLEMENTED=501,         // AUTHENTICATION NOT IMPLEMENTED YET :(
    REASON_DUPLICATED_SESSION=502,      // DUPLICATED SESSION ID
    REASON_EXPIRED_PASSWORD=100,        // VALIDATE, HOWEVER MUST CHANGE PASSWORD NOW!
    REASON_EXPIRED_ACCOUNT=102,         // ACCOUNT EXPIRED. NOT USABLE
    REASON_DISABLED_ACCOUNT=103,        // ACCOUNT DISABLED BY ADMIN.
    REASON_UNCONFIRMED_ACCOUNT=104,     // ACCOUNT NOT CONFIRMED YET.
    REASON_BAD_ACCOUNT=105,             // INVALID OR NON-EXISTENT ACCOUNT
    REASON_BAD_PASSWORD=106,            // AUTHENTICATION FAILED.
    REASON_PASSWORD_INDEX_NOTFOUND=107, // Authentication Slot SlotId not found.
    REASON_BAD_PARAMETERS=993,          // BAD PARAMETERS.
    REASON_INVALID_DOMAIN=994,          // AUTHENTICATION FAILED.
    REASON_INVALID_AUTHENTICATOR=995,
    REASON_SESSIONLIMITS_EXCEEDED=996,
    REASON_ANSWER_TIMEDOUT=997,
    REASON_EXPIRED=998,
    REASON_UNAUTHENTICATED=999
};

static bool IS_PASSWORD_AUTHENTICATED(const Reason & reason)
{
    return reason == REASON_AUTHENTICATED || reason == REASON_EXPIRED_PASSWORD;
}

static const char * cREASON_AUTHENTICATED="Authenticated";
static const char * cREASON_INTERNAL_ERROR="Authentication Internal Error";
static const char * cREASON_NOT_IMPLEMENTED="Authentication not implemented yet";
static const char * cREASON_EXPIRED_PASSWORD="Password expired";
static const char * cREASON_EXPIRED_ACCOUNT = "Account expired";
static const char * cREASON_DISABLED_ACCOUNT = "Account disabled";
static const char * cREASON_UNCONFIRMED_ACCOUNT = "Account unconfirmed";
static const char * cREASON_BAD_ACCOUNT = "Invalid Account";
static const char * cREASON_BAD_PASSWORD = "Invalid password";
static const char * cREASON_PASSWORD_INDEX_NOTFOUND = "Authentication Slot SlotId Not Found";
static const char * cREASON_EXPIRED = "Expired authentication";
static const char * cREASON_UNAUTHENTICATED = "Not authenticated yet";
static const char * cREASON_ANSWER_TIMEDOUT = "Answer timed out";
static const char * cREASON_DUPLICATED_SESSION = "Session ID Duplicated Error";
static const char * cREASON_INVALID_AUTHENTICATOR = "Invalid or undefined authenticator";
static const char * cREASON_INVALID_DOMAIN = "Invalid domain name";
static const char * cREASON_SESSIONLIMITS_EXCEEDED = "Sessions limits exceeded";
static const char * cREASON_BAD_PARAMETERS = "Bad Parameters";
static const char * cNULL = "";

static const char * getReasonText(const Reason & reason)
{
    switch(reason)
    {
    case REASON_SESSIONLIMITS_EXCEEDED: return cREASON_SESSIONLIMITS_EXCEEDED;
    case REASON_INVALID_AUTHENTICATOR: return cREASON_INVALID_AUTHENTICATOR;
    case REASON_DUPLICATED_SESSION: return cREASON_DUPLICATED_SESSION;
    case REASON_AUTHENTICATED: return cREASON_AUTHENTICATED;
    case REASON_INTERNAL_ERROR: return cREASON_INTERNAL_ERROR;
    case REASON_NOT_IMPLEMENTED: return cREASON_NOT_IMPLEMENTED;
    case REASON_EXPIRED_PASSWORD: return cREASON_EXPIRED_PASSWORD;
    case REASON_EXPIRED_ACCOUNT: return cREASON_EXPIRED_ACCOUNT;
    case REASON_DISABLED_ACCOUNT: return cREASON_DISABLED_ACCOUNT;
    case REASON_UNCONFIRMED_ACCOUNT: return cREASON_UNCONFIRMED_ACCOUNT;
    case REASON_BAD_ACCOUNT: return cREASON_BAD_ACCOUNT;
    case REASON_BAD_PASSWORD: return cREASON_BAD_PASSWORD;
    case REASON_PASSWORD_INDEX_NOTFOUND: return cREASON_PASSWORD_INDEX_NOTFOUND;
    case REASON_ANSWER_TIMEDOUT: return cREASON_ANSWER_TIMEDOUT;
    case REASON_EXPIRED: return cREASON_EXPIRED;
    case REASON_UNAUTHENTICATED: return cREASON_UNAUTHENTICATED;
    case REASON_INVALID_DOMAIN: return cREASON_INVALID_DOMAIN;
    case REASON_BAD_PARAMETERS: return cREASON_BAD_PARAMETERS;
        break;
    }
    return cNULL;
}

struct AuthenticationSchemeUsedSlot
{
    AuthenticationSchemeUsedSlot(uint32_t id, uint32_t priority, bool isOptional) : slotId(id), orderPriority(priority), optional(isOptional)
    {
    }

    AuthenticationSchemeUsedSlot(uint32_t id, uint32_t priority, bool isOptional,AuthenticationSlotDetails _details) : slotId(id), orderPriority(priority), optional(isOptional), details(_details)
    {
    }

    uint32_t slotId;
    uint32_t orderPriority;
    bool optional;

    AuthenticationSlotDetails details;
};



struct RoleDetails
{
    RoleDetails() {}
    std::string roleName;
    std::string description;
};



}}


