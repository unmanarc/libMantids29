#include "random.h"

#include <openssl/rand.h>
#include <stdexcept>

using namespace std;
using namespace Mantids30::Helpers;


std::string Random::createRandomString(size_t length)
{
    // Define the character set containing all possible characters for the random string.
    const char charset[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    // Calculate the maximum index of the character set.
    const size_t maxIndex = (sizeof(charset) - 1);

    // Initialize the result string with the required length, filled with null characters.
    std::string randomString(length, '\0');

    // Use a vector to store the randomly generated bytes.
    std::vector<unsigned char> buffer(length);

    // Generate random bytes and store them in the buffer.
    if (RAND_bytes(buffer.data(), length))
    {
        // Convert each byte in the buffer to a character from the charset.
        for (size_t i = 0; i < length; ++i)
        {
            // Use the modulo operation to ensure the index is within bounds of the charset.
            randomString[i] = charset[buffer[i] % maxIndex];
        }
    }
    else
    {
        // Throw an exception if RAND_bytes fails to generate random bytes.
        throw std::runtime_error("RAND_bytes failed.");
    }

    // Return the generated random string.
    return randomString;
}

std::string Random::createRandomHexString(size_t length)
{
    // Each byte will be represented by 2 hexadecimal characters, so we double the length.
    length = length * 2;

    // Define the character set for hexadecimal digits.
    const char charset[] = "ABCDEF0123456789";

    // Calculate the maximum index of the character set.
    const size_t maxIndex = (sizeof(charset) - 1);

    // Initialize the result string with the required length, filled with null characters.
    std::string randomString(length, '\0');

    // Use a vector to store the randomly generated bytes.
    std::vector<unsigned char> buffer(length / 2);

    // Generate random bytes and store them in the buffer.
    if (RAND_bytes(buffer.data(), buffer.size()))
    {
        // Convert each byte in the buffer to two hexadecimal characters.
        for (size_t i = 0; i < buffer.size(); ++i)
        {
            unsigned char byte = buffer[i];

            // Get the first hexadecimal digit from the higher nibble of the byte.
            randomString[i * 2]     = charset[(byte >> 4) % maxIndex];

            // Get the second hexadecimal digit from the lower nibble of the byte.
            randomString[i * 2 + 1] = charset[byte % maxIndex];
        }
    }
    else
    {
        // Throw an exception if RAND_bytes fails to generate random bytes.
        throw std::runtime_error("RAND_bytes failed.");
    }

    // Return the generated random hexadecimal string.
    return randomString;
}

void Random::createRandomSalt32(
    unsigned char *salt)
{
    if (!RAND_bytes(salt, sizeof(uint32_t)))
    {
        throw std::runtime_error("RAND_bytes failed.");
    }
}

void Random::createRandomSalt128(
    unsigned char *salt)
{
    if (!RAND_bytes(salt, 16))
    {
        throw std::runtime_error("RAND_bytes failed.");
    }
}
