#include "socket_chain.h"
#include <thread>

using namespace Mantids30::Network::Sockets;

Socket_Chain::Socket_Chain(std::shared_ptr<Mantids30::Network::Sockets::Socket_Stream> _baseSocket, bool _deleteBaseSocketOnExit)
{
    m_endPointReached = false;
    m_deleteBaseSocketOnExit = _deleteBaseSocketOnExit;
    m_baseSocket = _baseSocket;
}


void Socket_Chain::waitUntilFinish()
{
    for (sChainVectorItem * sockItem : m_socketLayers)
    {
        if (!sockItem->detached)
        {
            sockItem->thr1.join();
            sockItem->thr2.join();

            sockItem->detached = true;
            sockItem->finished = true;
        }
    }
}

void Socket_Chain::removeSocketsOnExit()
{
    for (sChainVectorItem * sockItem : m_socketLayers)
    {
        if (sockItem->deleteFirstSocketOnExit)
        {
            //delete sockItem->sock[0];
            sockItem->sock[0] = nullptr;
        }
        if (sockItem->deleteSecondSocketOnExit)
        {
            //delete sockItem->sock[1];
            sockItem->sock[1] = nullptr;
        }
    }
}

Socket_Chain::~Socket_Chain()
{
    // Propagate the shutdownSocket
    Socket_Chain::shutdownSocket();

    // Wait for threads:
    waitUntilFinish();

    // Delete if needed.
    removeSocketsOnExit();

    // Remove items when all threads are down.
    for (sChainVectorItem * sockItem : m_socketLayers)
    {
        delete sockItem;
    }
    m_socketLayers.clear();

    // delete the base socket if needed.
    //if (deleteBaseSocketOnExit) delete baseSocket;
}


size_t Socket_Chain::getLayers()
{
    return m_socketLayers.size();
}

int Socket_Chain::getLayerReadResultValue(size_t layer, bool fwd)
{
    if (layer>=m_socketLayers.size()) return -2;
    // TODO: check this.
    return static_cast<sChainVectorItem *>(m_socketLayers[layer])->r0[fwd?0:1];
}

bool Socket_Chain::getLayerWriteResultValue(size_t layer, bool fwd)
{
    if (layer>=m_socketLayers.size()) return false;
    // TODO: check this.
    return static_cast<sChainVectorItem *>(m_socketLayers[layer])->w1[fwd?0:1];
}

std::pair<std::shared_ptr<Mantids30::Network::Sockets::Socket_Stream> , std::shared_ptr<Mantids30::Network::Sockets::Socket_Stream> > Socket_Chain::getSocketPairLayer(size_t layer)
{
    if (layer>=m_socketLayers.size())
        return std::make_pair(nullptr,nullptr);

    sChainVectorItem* sockItem = static_cast<sChainVectorItem*>(m_socketLayers[layer]);
    return std::make_pair(sockItem->sock[0], sockItem->sock[1]);
}

bool Socket_Chain::addToChain(ChainProtocols::Socket_Chain_ProtocolBase *chainElement, bool deleteAtExit)
{
    return addToChain( chainElement->makeSocketChainPair(),
                             deleteAtExit, // If it's not a  detached pointer, declare as false, if it's detached true (when Socket_Chain die, then, this chain element will die too)
                             true, // Second socket is generated by makeSocketChainPair, should be automatically deleted here.
                             chainElement->isServerMode(), // Server mode: true
                             false, // Detached is false (should wait until finalization when deleting Socket_Chain...)
                             chainElement->isEndPoint()
                             );
}

bool Socket_Chain::addToChain(std::pair<std::shared_ptr<Mantids30::Network::Sockets::Socket_Stream> , std::shared_ptr<Mantids30::Network::Sockets::Socket_Stream> > sockPairs, bool deleteFirstSocketOnExit, bool deleteSecondSocketOnExit, bool modeServer, bool detached, bool endPMode)
{
    if (m_endPointReached) return false;
    if (endPMode) m_endPointReached = true;

    sChainVectorItem * item = new sChainVectorItem;

    // Register on chain
    item->deleteFirstSocketOnExit = deleteFirstSocketOnExit;
    item->deleteSecondSocketOnExit = deleteSecondSocketOnExit;
    item->sock[0] = sockPairs.first;
    item->sock[1] = sockPairs.second;
    item->modeServer = modeServer;
    m_socketLayers.push_back(item);

    // Register on thread.
    sChainTElement * chainTElem1 = new sChainTElement;
    sChainTElement * chainTElem2 = new sChainTElement;

    chainTElem1->sockets[0] = item->sock[1];
    chainTElem1->sockets[1] = m_socketLayers.size()==1? m_baseSocket : static_cast<sChainVectorItem *>(m_socketLayers[m_socketLayers.size()-2])->sock[0];
    chainTElem1->modeFWD = true;
    chainTElem1->r0 = &(item->r0[0]);
    chainTElem1->w1 = &(item->w1[0]);

    chainTElem2->sockets[0] = chainTElem1->sockets[1];
    chainTElem2->sockets[1] = chainTElem1->sockets[0];
    chainTElem2->modeFWD = false;
    chainTElem2->r0 = &(item->r0[1]);
    chainTElem2->w1 = &(item->w1[1]);

    item->thr1 = std::thread(chainThread, chainTElem1);
    item->thr2 = std::thread(chainThread, chainTElem2);

    if (detached)
    {
        item->detached = true;
        item->thr1.detach();
        item->thr2.detach();
    }

    ///////////////////////////////////
    // Now we init this socket...
    bool r;
    if (modeServer)
        r = sockPairs.first->postAcceptSubInitialization();
    else
        r = sockPairs.first->postConnectSubInitialization();

    if (!r)
    {
        item->sock[0]->shutdownSocket();
        item->sock[1]->shutdownSocket();
    }

    return r;
}
bool Socket_Chain::isConnected()
{
    if (m_socketLayers.size() == 0 && !m_baseSocket) return false;
    std::shared_ptr<Mantids30::Network::Sockets::Socket_Stream>  curSocket = !m_socketLayers.size()? m_baseSocket : static_cast<sChainVectorItem *>(m_socketLayers[m_socketLayers.size()-1])->sock[0];
    return curSocket->isConnected() && m_baseSocket->isConnected();
}

int Socket_Chain::shutdownSocket(int mode)
{
    if (m_socketLayers.size() == 0 && !m_baseSocket) return -1;
    std::shared_ptr<Mantids30::Network::Sockets::Socket_Stream>  curSocket = !m_socketLayers.size()? m_baseSocket : static_cast<sChainVectorItem *>(m_socketLayers[m_socketLayers.size()-1])->sock[0];
    return curSocket->shutdownSocket(mode);
}

int Socket_Chain::partialRead(void *data, const uint32_t & datalen)
{
    if (m_socketLayers.size() == 0 && !m_baseSocket) return -1;
    std::shared_ptr<Mantids30::Network::Sockets::Socket_Stream>  curSocket = !m_socketLayers.size()? m_baseSocket : static_cast<sChainVectorItem *>(m_socketLayers[m_socketLayers.size()-1])->sock[0];
    int x = curSocket->partialRead(data,datalen);
    if (x<=0)
        return x;
    return x;
}

int Socket_Chain::partialWrite(const void *data, const uint32_t &datalen)
{
    if (m_socketLayers.size() == 0 && !m_baseSocket) return -1;
    std::shared_ptr<Mantids30::Network::Sockets::Socket_Stream>  curSocket = !m_socketLayers.size()? m_baseSocket : static_cast<sChainVectorItem *>(m_socketLayers[m_socketLayers.size()-1])->sock[0];
    int x = curSocket->partialWrite(data,datalen);
    if (x<=0)
        return x;
    return x;
}

void Socket_Chain::chainThread(sChainTElement *threadInfo)
{
    char buffer[4096];
    int bytesRead;
    bool writeSuccess = false;

    while ((bytesRead = threadInfo->sockets[0]->partialRead(buffer, sizeof(buffer))) > 0 &&
           (writeSuccess = threadInfo->sockets[1]->writeFull(buffer, bytesRead)))
    {
        // Continue reading and writing
    }

    // Store the final read result
    *(threadInfo->r0) = bytesRead;

    // Store the final write success status
    *(threadInfo->w1) = writeSuccess;

    // Perform any necessary ending phase functions for stream sockets (if needed)

    // TODO: call ending phase functions for stream sockets...


    // Shutdown the sockets in appropriate direction
    threadInfo->sockets[0]->shutdownSocket(SHUT_RD);
    threadInfo->sockets[1]->shutdownSocket(SHUT_WR);

    delete threadInfo;
}
